# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute initial consumption given initial
#'  wealth in a life-cycle framework (\code{C++} functions)
#' 
#' @param income Income vector
#' @param K0 Initial wealth (fixed, estimated or calibrated)
#' @param r Exogeneous interest rate
#' @param timeIndex Time index (t=0,...,T-1) variable
#' @return Numerical value representing first period consumption
#'  in a life-cycle model without risk aversion (\code{C0_given_K0_noRA})
#'  or with risk aversion (\code{C0_given_K0_RA})
#'  @param timeIndex_var Time vector of t=0,..,T-1 moments
#'  
#' @export
C0_given_K0_noRA <- function(income, timeIndex, K0, r) {
    .Call(`_capitulation_C0_given_K0_noRA`, income, timeIndex, K0, r)
}

#' @rdname C0_given_K0_noRA
#' @param gamma Risk aversion coefficient
#' @export
C0_given_K0_RA <- function(income, timeIndex, K0, r, gamma) {
    .Call(`_capitulation_C0_given_K0_RA`, income, timeIndex, K0, r, gamma)
}

#' @rdname C0_given_K0_noRA
#' @param beta Utility discount factor
#' @export
C0_given_K0_beta <- function(income, timeIndex, K0, r, gamma, beta) {
    .Call(`_capitulation_C0_given_K0_beta`, income, timeIndex, K0, r, gamma, beta)
}

#' Determine household head for individual level data (C++ version)
#' 
#' \code{Rcpp} function to determine household referent from
#'  individual data. This is a necessary step to transform individual
#'  level data into household data. Vector should all be numeric formatted
#'  and the same length (internally this function uses a for loop).
#'  
#' @seealso \link{assign_referent} ; \link{assign_referent_R}
#'  
#' @details The following rules are applied:
#' \itemize{
#' \item{\emph{Immigrants}: Arrive without referent}
#' \item{\emph{Couples}: Male is assumed to be the head}
#' \item{\emph{Husband/Spouse death}: Individual is his/her own head}
#' \item{\emph{Divorce}: Individual is his/her own head}
#' \item{\emph{Potentially under father/mother authority}:
#'  If education is accomplished or young adult already earns income,
#'  individual is his/own head.
#' Father is assumed to be the household head. If father is dead,
#'  mother is the head. If she is dead, individual is his/her own head}
#' }
#' 
#' @param id Individual identifier
#' @param annee Observation/Simulation year
#' @param conjoint Husband/spouse identifier. Single people
#'  will be imputed a 0 value
#' @param sexe Sex. Males are coded 1 and females 2.
#' @param matri Matrimonious or family status. \emph{1}: leave parents ;
#'  \emph{2}: couple ; \emph{3}: husband/spouse death ; \emph{4}: divorce
#' @param referent,referent2 Household heads vector that will be imputed.
#'  Recommended to provide a vector of missing values.
#' @param findet Age where inidivudal stops education
#' @param age Current age of the individual
#' @param salaire Individual income
#' @param pere Father identifier
#' @param ageMaxPere Father death age
#' @param mere Mother identifier
#' @param ageMaxMere Mother death age
#' @param neFrance Origin of the individual. 1 for individual born
#'  in France ; 0 for immigrants
#'  
#' @return Dataframe storing individual identifier (\code{id}),
#'  year (\code{annee}), matrimonious status (\code{matri}),
#'  husband/spouse identifier (\code{conjoint}) and referent
#'  identifier (\code{referent})
#' @export
assign_referent_cpp <- function(id, annee, conjoint, sexe, matri, referent, referent2, findet, age, salaire, pere, ageMaxPere, mere, ageMaxMere, neFrance) {
    .Call(`_capitulation_assign_referent_cpp`, id, annee, conjoint, sexe, matri, referent, referent2, findet, age, salaire, pere, ageMaxPere, mere, ageMaxMere, neFrance)
}

#' Given measured wealth in survey, estimate/calibrate K0 (starting wealth).
#' 
#'  Calibrate K0 and C0 such that (i) individual leaves no wealth when he/she dies
#'  (ii) wealth level is consistent with observed level in 2009 (iii) consumption
#'  is fixed at C0 level. This function is programmed with \code{C++}.
#'  \code{calibrate_K0} is designed for risk neutral agents, \code{calibrate_K0_ra}
#'  for risk adverse agents
#'  
#' @section Warning:
#' To account for the possibility that familial structure evolves, it is possible
#' to give the number of consumption unit of the households. In that case,
#' C0 and K0 are values by consumption unit. To get household level values at
#' starting time $t=0$,
#' \eqn{C0*UC(0)$ and $K0*UC(0)} should be considered. To get household level consumption,
#' at time \eqn{t}, \eqn{C0 \times UC(t)} should be computed
#' 
#' @details
#' In pure permanent income approach with no inheritance, consumption path
#'  is fixed at a level such that agent does not leave any inheritance. The
#'  relationship between \eqn{K(t)} and \eqn{K(t-1)} is given by \eqn{K_t = (1+r)(K_{t-1}+Y_t-C_0)}
#'  with \eqn{C_0 = \frac{K_0+\sum_{t=0}^{T-1} \beta^t Y_t}{\sum_{t=0}^{T-1} \beta^t}}. By
#'  inverse recursion, K(0) can be determined from K(t)
#' @param age Age vector
#' @param income Income vector
#' @param findetVector End of studying year
#' @param K2009vector Measured wealth in survey data expressed as a
#'  vector
#' @param timeIndex Time index equals to zero except for
#'  observation year where it should be equal to 1.
#' @param UC Number of consumption unit in household at time t=0
#' @param r Exogeneous interest rate
#' @return List where first element (\code{K0}) is initial wealth
#'  and second element (\code{C0}) is life-cycle consumption
#' @export
#' @seealso \link{simulate_wealth_structural}
calibrate_K0 <- function(age, income, findetVector, K2009vector, timeIndex, UC, r) {
    .Call(`_capitulation_calibrate_K0`, age, income, findetVector, K2009vector, timeIndex, UC, r)
}

#' @rdname calibrate_K0
#' @param gamma Risk-aversion coefficient that gives instantaneous utility function curvature
#' @export
#' @seealso \link{simulate_wealth_structural}
calibrate_K0_ra <- function(age, income, findetVector, K2009vector, timeIndex, UC, r = 0.02, gamma = 0.5) {
    .Call(`_capitulation_calibrate_K0_ra`, age, income, findetVector, K2009vector, timeIndex, UC, r, gamma)
}

#' @rdname calibrate_K0
#' @param beta Utility discount rate
#' @export
calibrate_K0_beta <- function(age, income, findetVector, K2009vector, timeIndex, UC, r = 0.02, gamma = 0.5, beta = 1) {
    .Call(`_capitulation_calibrate_K0_beta`, age, income, findetVector, K2009vector, timeIndex, UC, r, gamma, beta)
}

#' Wealth transmission from year T-1 to T
#' 
#' Take last imputed year (T-1) and transmit
#'  wealth to year T given household change
#'  
#' @details Among the most remarkable rules:
#' \itemize{
#' \item{\emph{Divorce}: Household wealth divided between spouses}
#' \item{\emph{Marriage}: Household wealth merged between spouses}
#' }
#' 
#' @inheritParams assign_referent_cpp
#' @param patrimoine Wealth that has been
#'  imputed in a previous iteration 
#'  or that should be imputed before next
#'  iteration
#' @param year Year vector
#' @param matri_status Matrimonious or family status. \emph{1}: leave parents ;
#'  \emph{2}: couple ; \emph{3}: husband/spouse death ; \emph{4}: divorce
#' @param spouse_id Husband/Spouse identifier. Missing values if no
#'  husband/spouse
#' @param patrimoine_conjoint Husband/Spouse wealth
#' @param matri_conjoint Husband/Spouse matrimonious or family status. \emph{1}: leave parents ;
#'  \emph{2}: couple ; \emph{3}: husband/spouse death ; \emph{4}: divorce
#' @param year_loop T: loop year inside \code{inherit_wealth} is launched
#' @param referent_list List of household head in T-1
#'  
#' @return List: K[T-1], K[T] after demographic change
#' @export
inherit_wealth <- function(id, patrimoine, year, matri_status, sexe, spouse_id, patrimoine_conjoint, matri_conjoint, year_loop, referent_list) {
    .Call(`_capitulation_inherit_wealth`, id, patrimoine, year, matri_status, sexe, spouse_id, patrimoine_conjoint, matri_conjoint, year_loop, referent_list)
}

#' Determine K0 in a life-cycle model.
#' 
#' @inheritParams life_cycle_model_cpp
#' @param K2009vector Observed wealth in survey data
#' @param UC Number of consumption units
fit_K0_old <- function(income, K2009vector, timeIndex, UC, r = 0.02, gamma = 0.5, beta = 1) {
    .Call(`_capitulation_fit_K0_old`, income, K2009vector, timeIndex, UC, r, gamma, beta)
}

#' Determine K0 in a life-cycle model.
#' 
#' @inheritParams life_cycle_model_cpp
#' @param K2009vector Observed wealth in survey data
#' @param UC Number of consumption units
#' @export
fit_K0 <- function(income, K2009vector, timeIndex, UC, inheritanceReceived, inheritanceGiven, r = 0.02, gamma = 0.5, beta = 1) {
    .Call(`_capitulation_fit_K0`, income, K2009vector, timeIndex, UC, inheritanceReceived, inheritanceGiven, r, gamma, beta)
}

#' Intermediate function to compute some parameters
#' @inheritParams life_cycle_model_cpp
#' @param UC Number of consumption units
#' @export
param_K0 <- function(r, gamma, beta, income, UC) {
    .Call(`_capitulation_param_K0`, r, gamma, beta, income, UC)
}

#' [Discarded] Estimate wealth accumulation with a life-cycle model
#' 
#' See \link{life_cycle_model} for the current implementation.
#' Given individualized income trajectory and one
#' observed wealth point in time,
#' determine wealth trajectory in a life-cycle model
#' (see \code{details}). People whom wealth is
#' not observed at any time are assumed to start
#' without wealth (\eqn{K_0 = 0}). Functions differ
#' in the structure of input required or output returned
#' 
#' @details These functions are designed to determine
#'  the full individual wealth dynamics given income
#'  trajectory. It is assumed that an observed wealth
#'  vector \code{K2009vector} is provided where only
#'  one value is meaningful, the one where \code{timeIndex}
#'  is equal to one (observation dummy).
#'  These functions implementat of
#'  Modigliani-Friedman model in a context of
#'  microsimulation where every year income is observed
#' \describe{
#'   \item{life_cycle_model_cpp}{Interest rate
#'   as a parameter. Return as a list:
#'   \itemize{
#'     \item \eqn{K_0} consistent with \eqn{K_t} and
#'      model hypotheses
#'     \item \eqn{C_0} consistent with \eqn{K_0}
#'     \item \eqn{K_t} sequence
#'     }
#'   }
#'   \item{life_cycle_model_cpp2}{Same but only returns
#'    \eqn{K_t} sequence}
#'   \item{life_cycle_model_heterogeneity_cpp}{Interest rate
#'   as a vector. Return as a list:
#'   \itemize{
#'     \item \eqn{K_0} consistent with \eqn{K_t} and
#'      model hypotheses
#'     \item \eqn{C_0} consistent with \eqn{K_0}
#'     \item \eqn{K_t} sequence
#'     }
#'   }
#' }
#'  
#' @inheritParams estimate_K0
#' @inheritParams simulate_wealth_structural
#' @param K2009vector Observed wealth in survey data or
#'  missing value (in that case K0 will be 0) stored
#'  into long vector
#' @param timeIndex A 0/1 vector where 1 indicates
#'  year where individual is observed on wealth data
#' @param inheritanceGiven Vector storing inheritance that
#'  an individual wants to transmit when dying. Stored into
#'  long vector (i.e. a vector where each
#'  row presents the same value). Missing values are not
#'  allowed
#' @param inheritanceReceived Vector storing inheritance that
#'  an individual receives every year. Zero values when no
#'  inheritance is received and positive amount when
#'  the individual receives.
#' @export
life_cycle_model_cpp_old <- function(income, K2009vector, timeIndex, UC, r = 0.02, gamma = 0.5, beta = 1, returnLast = FALSE) {
    .Call(`_capitulation_life_cycle_model_cpp_old`, income, K2009vector, timeIndex, UC, r, gamma, beta, returnLast)
}

#' @rdname life_cycle_model_cpp_old
#' @export
life_cycle_model_cpp2_old <- function(income, K2009vector, timeIndex, UC, inheritanceGiven, inheritanceReceived, r = 0.02, gamma = 0.5, beta = 1, returnLast = FALSE) {
    .Call(`_capitulation_life_cycle_model_cpp2_old`, income, K2009vector, timeIndex, UC, inheritanceGiven, inheritanceReceived, r, gamma, beta, returnLast)
}

#' Estimate wealth accumulation with a life-cycle model
#' 
#' Given individualized income trajectory, one
#' observed wealth point in time and a model prediction for
#' inheritance,
#' determine wealth trajectory in a life-cycle model.
#' This implementation uses the closed form formula
#' presented in the paper. 
#' 
#' @details These functions are designed to determine
#'  the full individual wealth dynamics given income
#'  trajectory. It is assumed that an observed wealth
#'  vector \code{observed_wealth} is provided where only
#'  one value is meaningful, the one where \code{timeIndex}
#'  is equal to one (observation dummy).
#'  These functions implement Modigliani-Friedman model 
#'  augmented with inheritance in a context of
#'  microsimulation where every year income is observed
#'  
#' @param income Income vector
#' @param pi Surival probability vector
#' @param observed_wealth Observed wealth in survey data or
#'  stored into long vector (i.e. a vector where each
#'  row presents the same value). Missing values are not
#'  allowed
#' @param timeIndex A 0/1 vector where 1 indicates
#'  year where individual is observed on wealth data
#' @param inheritanceGiven Vector storing inheritance that
#'  an individual wants to transmit when dying. Stored into
#'  long vector (i.e. a vector where each
#'  row presents the same value). Missing values are not
#'  allowed
#' @param inheritanceReceived Vector storing inheritance that
#'  an individual receives every year. Zero values when no
#'  inheritance is received and positive amount when
#'  the individual receives.
#' @param r Interest rate vector. Because we assume an individual
#'  faces the same interest rate every year, only the first value
#'  is used
#' @param gamma Risk-aversion coefficient
#' @param beta Discount factor
#' 
#' @return The sequence of an individual wealth: \eqn{(K_t)_t} vector
#' @export
life_cycle_model_cpp <- function(income, observed_wealth, pi, timeIndex, inheritanceGiven, inheritanceReceived, r, risk_aversion, discount_factor, scale_model = "level", outcome = "wealth") {
    .Call(`_capitulation_life_cycle_model_cpp`, income, observed_wealth, pi, timeIndex, inheritanceGiven, inheritanceReceived, r, risk_aversion, discount_factor, scale_model, outcome)
}

#' Same function than life_cycle_model_cpp with the
#'  additional possibility of having K_{T+1}
#' @inheritParams life_cycle_model_cpp
#' @param return_last Logical value indicating whether
#'  we would like to return last value
life_cycle_model_cpp_bis <- function(income, observed_wealth, pi, timeIndex, inheritanceGiven, inheritanceReceived, r, risk_aversion, discount_factor, scale_model = "level", return_last = FALSE) {
    .Call(`_capitulation_life_cycle_model_cpp_bis`, income, observed_wealth, pi, timeIndex, inheritanceGiven, inheritanceReceived, r, risk_aversion, discount_factor, scale_model, return_last)
}

life_cycle_model_cpp_uncertainty <- function(income, observed_wealth, pi, timeIndex, inheritanceGiven, inheritanceReceived, r, risk_aversion, discount_factor, scale_model = "level") {
    .Call(`_capitulation_life_cycle_model_cpp_uncertainty`, income, observed_wealth, pi, timeIndex, inheritanceGiven, inheritanceReceived, r, risk_aversion, discount_factor, scale_model)
}

#' Same function than life_cycle_model_cpp with the
#'  additional possibility of having K_{T+1}
#' @inheritParams life_cycle_model_cpp
#' @param return_last Logical value indicating whether
#'  we would like to return last value
life_cycle_model_cpp_bis_uncertainty <- function(income, observed_wealth, pi, timeIndex, inheritanceGiven, inheritanceReceived, r, risk_aversion, discount_factor, scale_model = "level", return_last = FALSE) {
    .Call(`_capitulation_life_cycle_model_cpp_bis_uncertainty`, income, observed_wealth, pi, timeIndex, inheritanceGiven, inheritanceReceived, r, risk_aversion, discount_factor, scale_model, return_last)
}

#' A wrapper to transform list into inputs to life cycle model functions
#' @inheritParams life_cycle_model_cpp2_old
#' @param elem List of data
#' @param f Function to apply many times
#' @param id_var Identifier variable name
#' @param annee_var Time vector name
#' @param income_var Income variable name
#' @param observed_wealth_var Observed wealth variable name
#' @param time_var 0-1 variable name with 1 for 2009 value
#' @param weight_var Weight variable. See \link{prepare_data}
#' @param inheritanceGiven_var Inheritance given variable
#' @param inheritanceReceived_var Inheritance received variable
#' @export
#' 
wrapper_function <- function(elem, f, id_var = "Id", annee_var = "annee", income_var = "salaire_tot", observed_wealth_var = "wealth2009", time_var = "tt", weight_var = "UC", inheritanceGiven_var = "H_given", inheritanceReceived_var = "H_received", r = 0.02, gamma = 0.5, beta = 1, returnLast = FALSE) {
    .Call(`_capitulation_wrapper_function`, elem, f, id_var, annee_var, income_var, observed_wealth_var, time_var, weight_var, inheritanceGiven_var, inheritanceReceived_var, r, gamma, beta, returnLast)
}

#' Life cycle model
#' @inheritParams wrapper_function
#' @inheritParams life_cycle_model_cpp2_old
#' @param input List of data
#' @param Hgiven_var Inheritance given variable
#' @param Hreceived_var Inheritance received variable
#' @export
#' @return A list of dataframe
#' 
life_cycle_apply <- function(input, f, id_var = "Id", annee_var = "annee", income_var = "salaire_tot", observed_wealth_var = "wealth2009", time_var = "tt", weight_var = "UC", Hgiven_var = "tempHg", Hreceived_var = "tempHr", r = 0.02, gamma = 0.5, beta = 1, returnLast = FALSE) {
    .Call(`_capitulation_life_cycle_apply`, input, f, id_var, annee_var, income_var, observed_wealth_var, time_var, weight_var, Hgiven_var, Hreceived_var, r, gamma, beta, returnLast)
}

uncertainty_conso <- function(income, observed_wealth, pi, timeIndex, inheritanceGiven, inheritanceReceived, r, risk_aversion, discount_factor, scale_model = "level") {
    .Call(`_capitulation_uncertainty_conso`, income, observed_wealth, pi, timeIndex, inheritanceGiven, inheritanceReceived, r, risk_aversion, discount_factor, scale_model)
}

#' Simulate Kt all along time period for a given K0 (starting wealth)
#' 
#' Capitalize wealth given capital dynamics $K_t = (1+r)(K_{t-1}+Y_t-C_0)$,
#'  initial capital (K0), consumption (C0) and income dynamics. Different
#'  functions that are associated with different models
#'  \itemize{
#'     \item \code{simulate_wealth_structural}: simplest life cycle model where
#'       \eqn{\beta =1} and no risk aversion
#'     \item \code{simulate_wealth_structural}: life cycle model with
#'       \eqn{\beta =1 } and risk aversion
#'     \item \code{simulate_wealth_structural}: complete life cycle model with
#'       \eqn{\beta \leq 1} and risk aversion
#'  }
#' 
#' @param income Income vector
#' @param r Exogeneous interest rate
#' @param K0 Capital for the first period
#' @param consumption0 Consumption path
#' @param returnLast Return last element
#' @export
#' @seealso \link{calibrate_K0}
simulate_wealth_structural <- function(K0, consumption0, income, UC, r = 0.02, returnLast = FALSE) {
    .Call(`_capitulation_simulate_wealth_structural`, K0, consumption0, income, UC, r, returnLast)
}

#' @rdname simulate_wealth_structural
#' @inheritParams calibrate_K0
#' @export
simulate_wealth_structural_ra <- function(K0, consumption0, income, UC, r = 0.02, gamma = 0.5, returnLast = FALSE) {
    .Call(`_capitulation_simulate_wealth_structural_ra`, K0, consumption0, income, UC, r, gamma, returnLast)
}

#' @rdname simulate_wealth_structural
#' @param beta Utility discount factor
#' @export
simulate_wealth_structural_beta <- function(K0, consumption0, income, UC, r = 0.02, gamma = 0.5, beta = 1, returnLast = FALSE) {
    .Call(`_capitulation_simulate_wealth_structural_beta`, K0, consumption0, income, UC, r, gamma, beta, returnLast)
}

#' @rdname simulate_wealth_structural
#' @inheritParams simulate_wealth_structural_beta
#' @param tau Time vector since active life began 
#' @export
simulate_wealth_structural_beta2 <- function(K0, consumption0, income, UC, tau, r = 0.02, gamma = 0.5, beta = 1, returnLast = FALSE) {
    .Call(`_capitulation_simulate_wealth_structural_beta2`, K0, consumption0, income, UC, tau, r, gamma, beta, returnLast)
}

#' Wrapper for vector subsetting in Rcpp
#' 
#' @param x Numeric vector
#' @param start Index start. Indexation follows C++ rule hence begins at 0
#' @param end Index of ending. Indexation follows C++ rule hence ends at n-1
#' 
#' @return x values between \code{start} and \code{end}
subset_range <- function(x, start = 0L, end = 1L) {
    .Call(`_capitulation_subset_range`, x, start, end)
}

